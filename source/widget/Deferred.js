// Generated by CoffeeScript 1.6.3
/*
 Standalone Deferred
 Copyright 2012 Otto Vehvil√§inen
 Released under MIT license

 This is a standalone implementation of the wonderful jQuery.Deferred API.
 The documentation here is only for quick reference, for complete api please
 see the great work of the original project:

 http://api.jquery.com/category/deferred-object/
 */

var __slice = [].slice,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

define(function() {
  var Deferred, Promise, after, isObservable, _when;
  if (!Array.prototype.forEach) {
    throw new Error("Deferred requires Array.forEach");
  }
  /*
   Tells if an object is observable
   */

  isObservable = function(obj) {
    return (obj instanceof Deferred) || (obj instanceof Promise);
  };
  after = function(times, func) {
    if (times <= 0) {
      return func();
    }
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };
  /*
   Promise object functions as a proxy for a Deferred, except
   it does not let you modify the state of the Deferred
   */

  Promise = (function() {
    Promise.prototype._deferred = null;

    function Promise(deferred) {
      this._deferred = deferred;
    }

    Promise.prototype.done = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      (_ref = this._deferred).done.apply(_ref, args);
      return this;
    };

    Promise.prototype.fail = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      (_ref = this._deferred).fail.apply(_ref, args);
      return this;
    };

    Promise.prototype.pipe = function(doneFilter, failFilter) {
      return this._deferred.pipe(doneFilter, failFilter);
    };

    Promise.prototype.then = function(doneFilter, failFilter) {
      return this._deferred.pipe(doneFilter, failFilter);
    };

    Promise.prototype.state = function() {
      return this._deferred.state();
    };

    return Promise;

  })();
  Deferred = (function() {
    /*
     Initializes a new Deferred. You can pass a function as a parameter
     to be executed immediately after init. The function receives
     the new deferred object as a parameter and this is also set to the
     same object.
     */

    function Deferred(fn) {
      this.resolve = __bind(this.resolve, this);
      this.reject = __bind(this.reject, this);
      this.promise = __bind(this.promise, this);
      this.progress = __bind(this.progress, this);
      this.pipe = __bind(this.pipe, this);
      this.notify = __bind(this.notify, this);
      this.fail = __bind(this.fail, this);
      this.done = __bind(this.done, this);
      this._state = 'pending';
      if (typeof fn === 'function') {
        fn.call(this, this);
      }
    }

    /*
     Pass in functions or arrays of functions to be executed when the
     Deferred object is resolved. If the object has already been resolved,
     the functions are executed immediately. If the object has been rejected,
     nothing happens. The functions receive the arguments that are passed
     to resolve and this is set to the object defined by resolveWith if that
     variant is used.
     */


    Deferred.prototype.done = function() {
      var args, _ref,
        _this = this;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        return this;
      }
      if (this._state === 'resolved') {
        args.forEach(function(fn) {
          return fn.apply(null, _this._withArguments);
        });
      } else if (this._state === 'pending') {
        this._doneCallbacks || (this._doneCallbacks = []);
        (_ref = this._doneCallbacks).push.apply(_ref, args);
      }
      return this;
    };

    /*
     Pass in functions or arrays of functions to be executed when the
     Deferred object is rejected. If the object has already been rejected,
     the functions are executed immediately. If the object has been resolved,
     nothing happens. The functions receive the arguments that are passed
     to reject and this is set to the object defined by rejectWith if that
     variant is used.
     */


    Deferred.prototype.fail = function() {
      var args, _ref,
        _this = this;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0) {
        return this;
      }
      if (this._state === 'rejected') {
        args.forEach(function(fn) {
          return fn.apply(null, _this._withArguments);
        });
      } else if (this._state === 'pending') {
        this._failCallbacks || (this._failCallbacks = []);
        (_ref = this._failCallbacks).push.apply(_ref, args);
      }
      return this;
    };

    /*
     Notify progress callbacks with additional context. Works the same way as notify(),
     except this is set to context when calling the functions.
     */


    Deferred.prototype.notify = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this._state !== 'pending') {
        return this;
      }
      if ((_ref = this._progressCallbacks) != null) {
        _ref.forEach(function(fn) {
          return fn.apply(null, args);
        });
      }
      return this;
    };

    /*
     Returns a new Promise object that's tied to the current Deferred. The doneFilter
     and failFilter can be used to modify the final values that are passed to the
     callbacks of the new promise. If the parameters passed are falsy, the promise
     object resolves or rejects normally. If the filter functions return a value,
     that one is passed to the respective callbacks. The filters can also return a
     new Promise or Deferred object, of which rejected / resolved will control how the
     callbacks fire.
     */


    Deferred.prototype.pipe = function(doneFilter, failFilter) {
      var def;
      def = new Deferred();
      this.done(function() {
        var args, result;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (doneFilter != null) {
          result = doneFilter.apply(null, args);
          if (isObservable(result)) {
            return result.done(function() {
              var doneArgs;
              doneArgs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              return def.resolve.apply(def, doneArgs);
            }).fail(function() {
                var failArgs;
                failArgs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                return def.reject.apply(def, failArgs);
              });
          } else {
            return def.resolve(result);
          }
        } else {
          return def.resolve.apply(def, args);
        }
      });
      this.fail(function() {
        var args, result;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (failFilter != null) {
          result = failFilter.apply(null, args);
          if (isObservable(result)) {
            result.done(function() {
              var doneArgs;
              doneArgs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
              return def.resolve.apply(def, doneArgs);
            }).fail(function() {
                var failArgs;
                failArgs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                return def.reject.apply(def, failArgs);
              });
          } else {
            def.reject(result);
          }
          return def.reject.apply(def, args);
        } else {
          return def.reject.apply(def, args);
        }
      });
      return def.promise();
    };

    /*
     Add progress callbacks to be fired when using notify()
     */


    Deferred.prototype.progress = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (args.length === 0 || this._state !== 'pending') {
        return this;
      }
      this._progressCallbacks || (this._progressCallbacks = []);
      (_ref = this._progressCallbacks).push.apply(_ref, args);
      return this;
    };

    /*
     Returns the promise object of this Deferred.
     */


    Deferred.prototype.promise = function() {
      return this._promise || (this._promise = new Promise(this));
    };

    /*
     Reject this Deferred with additional context. Works the same way as reject, except
     the first parameter is used as this when calling the fail and always callbacks.
     */


    Deferred.prototype.reject = function() {
      var args, _ref,
        _this = this;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this._state !== 'pending') {
        return this;
      }
      this._state = 'rejected';
      this._withArguments = args;
      if ((_ref = this._failCallbacks) != null) {
        _ref.forEach(function(fn) {
          return fn.apply(null, args);
        });
      }
      return this;
    };

    /*
     Resolve this Deferred with additional context. Works the same way as resolve, except
     the first parameter is used as this when calling the done and always callbacks.
     */


    Deferred.prototype.resolve = function() {
      var args, _ref,
        _this = this;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this._state !== 'pending') {
        return this;
      }
      this._state = 'resolved';
      this._withArguments = args;
      if ((_ref = this._doneCallbacks) != null) {
        _ref.forEach(function(fn) {
          return fn.apply(null, args);
        });
      }
      return this;
    };

    /*
     Returns the state of this Deferred. Can be 'pending', 'rejected' or 'resolved'.
     */


    Deferred.prototype.state = function() {
      return this._state;
    };

    return Deferred;

  })();
  /*
   Returns a new promise object which will resolve when all of the deferreds or promises
   passed to the function resolve. The callbacks receive all the parameters that the
   individual resolves yielded as an array. If any of the deferreds or promises are
   rejected, the promise will be rejected immediately.
   */

  _when = function() {
    var allDoneArgs, allReady, args, finish;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (args.length === 0) {
      return new Deferred().resolve().promise();
    }
    if (args.length === 1) {
      if (isObservable(args[0])) {
        return args[0].promise();
      }
      return new Deferred().resolve(args[0]).promise();
    }
    allReady = new Deferred();
    allDoneArgs = [];
    finish = after(args.length, function() {
      return allReady.resolve.apply(allReady, allDoneArgs);
    });
    args.forEach(function(dfr, index) {
      if (isObservable(dfr)) {
        return dfr.done(function() {
          var doneArgs;
          doneArgs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          allDoneArgs[index] = doneArgs.length > 1 ? doneArgs : doneArgs[0];
          return finish();
        }).fail(allReady.reject);
      } else {
        allDoneArgs[index] = dfr;
        return finish();
      }
    });
    return allReady.promise();
  };
  return {
    Deferred: function() {
      return new Deferred();
    },
    when: _when
  };
});
